function P=pfreq2db_paros(fn)
%function P=pfreq2db_paros(cdfs)
%m-fcn to get pressure in decibars from external paros frequency pressure sensor on Sontek
%ADV hydra system



cdfs = netcdf(fn,'nowrite');

metadata.pressinstalled = cdfs.PressInstalled(:);
metadata.pressscale = cdfs.PressScale(:);
metadata.pressoffset = cdfs.PressOffset(:);
metadata.compassoffset = cdfs.CompassOffset(:);
metadata.pressfreqoffset = cdfs.PressFreqOffset(:);
metadata.extsensorinstalled = cdfs.ExtSensorInstalled(:);
metadata.extpressinstalled = cdfs.ExtPressInstalled(:);
metadata.pressscale_2 = cdfs.PressScale_2(:);

% build the static part of the pressure data structure needed for hydrapress2db
%if ~isempty(cdfs{'extpressfreq'}) || ~isempty(cdfs{'extpress'}) || ~isempty(cdfs{'pressure'}),
if 1
    P.ExtPressInstalled = metadata.extpressinstalled; % 'No' | 'Paros' | 'Druck' | 'ParosFreq'
    P.PressFreqOffset = metadata.pressfreqoffset;
    P.PressOffset = metadata.pressoffset;
    P.PressScale = metadata.pressscale;
    P.PressScale_2 = metadata.pressscale_2;
    P.INST_TYPE = cdfs.INST_TYPE(:);
    % frequency sensor case
    if strcmp(P.ExtPressInstalled,'Druck') || strcmp(P.ExtPressInstalled,'ParosFreq'),
        P.presscals = get_calvalues(cdfs{'MeanExtpressfreq'});
        if isempty(P.presscals),
            disp('Expected to find frequency pressure calibrations and did not.')
            disp('Pressure will not be processed')
        end
    else P.presscals = [];
    end
%     P.omit = find(~switches.override_pmask);
%     if ~isempty(P.omit), P.nanmask = ones(1,length(P.omit)).*NaN; end
else
    P = [];
end
 if ~isempty(cdfs{'MeanTemperature'}), Adv.temperature{1} = (cdfs{'MeanTemperature'}(:,:))'; end; % ADV probe temp
 if ~isempty(cdfs{'MeanExtpressfreq'}), Adv.extpressfreq{1} = (cdfs{'MeanExtpressfreq'}(:,:))'; end % pressure frequency, Hz
    if isfield(Adv,'temperature'), P.temp = Adv.temperature{1}; end % temperature, deg C
        if isfield(Adv,'extpressfreq'), 
            P.extpressfreq = Adv.extpressfreq{1};
            % get rid of the spikes, if there are any
            if isfield(P,'nanmask'), P.extpressfreq(P.omit) = P.nanmask; end
        end
        % fields will come back empty if cal could not be done
        P = hydrapress2db(P);  % this will sort out freq vs serial vs strain guage pressure
        Adv.pressdb{1}= P.pressdb; 
    
end
%%
% GET_CALVALUES convert calibrations in a structure to a netcdf attribute
% cdfobj = cdf variable
% cals = structure with cal constants

function cals = get_calvalues(cdfvarobj)
theAtts = att(cdfvarobj);  % attribute objects
cals = [];
for i = 1:length(theAtts),
    if findstr(char(ncnames(theAtts{i})),'cal_'),
        % strtok randomly truncated the name...
        %[token, rem] = strtok(char(ncnames(theAtts{i})),'cal_');
        token = strread(char(ncnames(theAtts{i})),'cal_%s');
        eval(sprintf('cals.%s = theAtts{i}(:);',char(token)));
    end
end
end

%%
% hydrapress2db - read and convert pressure stored by a Sontek Hydra in a *.cdf file
% there are two ways to use this function... direct from a file, or, in processing
% function p = hydrapress2db(cdfsfile, druckfile, [bursts], [cdfsfile]) for folks who
%           want to directly inspect or extract pressure from a cdf file
% cdfsfile   = netCDF burst file generated by adp2cdf or adr2cdf from Sontek Hydra .adp or .adr files
% cdfsfile   = netCDF statistics file generated by adp2cdf or adr2cdf from Sontek Hydra .adp or .adr files
%           the statistics file is only used if temperature is missing from the burst file
% druckfile = the name of the Hydra pressure calibration file (Druck file .drk)
% bursts    = [startburst endburst] which bursts to process, if omitted, it will read them all
%           so make sure you have enough RAM, they're big!
% function p = hydrapress2db(p) for use in a processing file
%           where p is a structure already containing the data needed:
%           if you really know what you're doing, you only need pass the
%           data specific to the sensor that was attached.
%             p.ExtPressInstalled = cdf.ExtPressInstalled(:); % 'No' | 'Paros' | 'Druck' | 'ParosFreq'
%             p.PressOffset = cdf.PressOffset(:);
%             p.PressScale = cdf.PressScale(:);
%             p.PressScale_2 = cdf.PressScale_2(:);
%             p.PressFreqOffset = cdf.PressFreqOffset(:);
%             p.temp = cdf{'temperature'}(bursts(1):bursts(2),:); % temperature, deg C
%             p.extpress = cdf{'extpress'}(bursts(1):bursts(2),:);    % pressure, counts, least significant bits
%             p.stdpress = cdf{'StdPressure'}(bursts(1):bursts(2),:); % std of pressure, for strain guage or smart paros or ADV paros
%             p.extpressfreq = cdf{'extpressfreq'}(bursts(1):bursts(2),:);
%             p.presscals = calibration constants
%             p.INST_TYPE = cdf.INST_TYPE(:);
%             p.pressdb = calibrate pressure in db
%             p.extpressdb = std. dev. of the calibrated burst pressure in db
%
% TODO need to fix stdpress... which is it, the ADV statistic generated for each sample, or the STD of the burst
% TODO strain guage PCADP | ADV: std of press is real in binary
% TODO PCADP PCmode --- no profile std of pressure
% TODO       non-PCmode - yes, profile std of pressure
% TODO do we want to make this work only on burst data

% Written by Marinna Martini for the U.S. Geological Survey 
% Coastal & Marine Program Woods Hole Field Center, Woods Hole, MA
% http://woodshole.er.usgs.gov/ Please report bugs to mmartini@usgs.gov

% 19-feb-2015 act gracefully if pressure stats are not recorded
% 14-oct-2009 add handling for internal pressure
% 14-apr-2006 add handling for serial paros pressure
% 11-may-2005 deal with ADV data that doesn't have burst temperature, when
% command line (non P structure) version is used.
% 19-oct-2004 fix druck code and test, looks OK on one data file
% 26-Sep-2004 add druck code, but have no data to test it with
% 29-Aug-2004
% 9-Apr-2004 first version

% TODO make this abort gracefully if temperature data are missing

function p = hydrapress2db(varargin)

% first, did we get a filename or a structure
if ischar(varargin{1}), % must read the data file the file right here.    
    if ~isempty(varargin), cdfsfile = varargin{1}; end
    if length(varargin) > 1, druckfile = varargin{2}; end
    if length(varargin) > 2, bursts = varargin{3}; end
    if length(varargin) > 3, cdfsfile = varargin{4}; end
    
    if exist('cdfsfile') ~=1,    
        [fname, pathname, filterindex] = uigetfile('*.cdf', 'Pick a netcdf file containing Sontek Hydra data');
        if isequal(fname,0) || isequal(pathname,0)
            disp('User pressed cancel')
            p = [];
            return
        end
        cdfsfile = fullfile(pathname, fname);
        disp(['User selected ', cdfsfile])
    end
    %[pathstr,filename,fileext,versn] = fileparts(cdfsfile);
    % make sure this is a Hydra data file
    cdf = netcdf(cdfsfile,'nowrite');
    if isempty(cdf), 
        disp(['Cannot open ',cdfsfile])
        p = [];
        return
    end
    if ~strcmp(cdf.INST_TYPE(:),'Sontek ADV') && ~strcmp(cdf.INST_TYPE(:),'Sontek PCADP'),
        disp('File is not a Sontek Hydra data file')
        close (cdf)
        p = [];
        return
    end

    % get pressure cals, druck files are the same for PCADP and ADV
    if ~exist('druckfile'), druckfile = []; end
    [druck, paros] = readdruck(druckfile);
    if ~isempty(druck), p.presscals = druck;
    elseif ~isempty(paros), p.presscals = paros;
    else p.presscals = [];
    end
    
    if exist('bursts') ~= 1, % get them all by default
        bursts = [1 length(cdf{'burst'})];
        if bursts(2) == 0,    bursts = [1 length(cdf{'burst'})]; end
    elseif find(bursts < 1), % no negative indeces
        disp('Cannot use negative indeces')
        close (cdf)
        p = [];
        return
    end
    
    p.ExtPressInstalled = cdf.ExtPressInstalled(:); % 'No' | 'Paros' | 'Druck' | 'ParosFreq'
    p.sensor_depth = cdf.WATER_DEPTH(:)-cdf.xducer_offset(:); 
    p.PressOffset = cdf.PressOffset(:);
    p.PressScale = cdf.PressScale(:);
    p.PressScale_2 = cdf.PressScale_2(:);
    p.PressFreqOffset = cdf.PressFreqOffset(:);
    p.burstNum = cdf{'burst'}(bursts(1):bursts(2)); 
    p.temp = cdf{'temperature'}(bursts(1):bursts(2),:); % temperature, deg C
    p.MeanPress = cdf{'pressure'}(bursts(1):bursts(2),:);  % pressure, for strain guage or smart paros or ADV paros
    p.extpress = cdf{'extpress'}(bursts(1):bursts(2),:);    % pressure, counts, least significant bits
    p.stdpress = cdf{'StdPressure'}(bursts(1):bursts(2),:); % std of pressure, for strain guage or smart paros or ADV paros
    p.extpressfreq = cdf{'extpressfreq'}(bursts(1):bursts(2),:);
    p.jt = cdf{'time'}(bursts(1):bursts(2),:)+cdf{'time2'}(bursts(1):bursts(2),:)./(24*3600*1000);
    p.profilenum = cdf{'profile'}(bursts(1):bursts(2),:); % count
    p.INST_TYPE = cdf.INST_TYPE(:);
    close (cdf);
    
    if isempty(p.temp), 
        if exist('cdfsfile') ~=1,
            [fname, pathname, filterindex] = uigetfile('*.cdf', 'Pick a netcdf stats file containing Sontek Hydra data with temperature');
            if isequal(fname,0) || isequal(pathname,0)
                disp('User pressed cancel')
                p = [];
                return
            end
            cdfsfile = fullfile(pathname, fname);
            disp(['User selected ', cdfsfile])
        end
        cdf = netcdf(cdfsfile,'nowrite');
        if isempty(cdf),
            disp(['Cannot open ',cdfsfile])
            p = [];
            return
        end
        if ~isempty(cdf{'MeanTemperature'}), 
            p.temp = cdf{'MeanTemperature'}(bursts(1):bursts(2)); % ADV probe temp
        end
    end
    
    if isempty(p.temp), % one last failsafe check
        disp('hydrapress2db: no temperature data for pressure conversion')
        p = [];
        return
    end

    
elseif isstruct(varargin{1}),
    % function p = hydrapress2db(p) for use in a processing file
    p = varargin{1};
else
    disp('hydrapress2db: invalid input')
    p = [];
    return
end

switch p.ExtPressInstalled,
    case 'No', % strain guage pressure
        % but still can be missing stdpress data
        % convert units on calibration info, do it here so I don't get confused
        PressScale = p.PressScale / 1e8; % nanobar/count to db/count
        PressOffset = p.PressOffset / 1e5; % microbar to db
        % TODO I'm not so sure of this last one.
        PressScale_2 = p.PressScale_2 / 1e12; % picodbar / (count ^2)
        %p.stdpressdb = p.PressScale.*p.stdpress;
        if isfield(p,'stdpress'),
            p.stdpressdb = PressScale.*p.stdpress;
        end
        if isfield(p,'MeanPress'),
            p.pressdb = PressOffset + PressScale.*p.MeanPress + PressScale_2.*(p.MeanPress.^2);
            %fprintf('Pressure, db = %5.2f\n',gmean(p.pressdb))
        elseif isfield(p,'pressure'),
            p.pressdb = PressOffset + PressScale.*p.pressure + PressScale_2.*(p.pressure.^2);
        end            
    case {'ParosFreq', 'Druck'},
        if ~isempty(p.presscals), % if there are cal constants
            % note that MeanTemp was converted to degrees when read from the binary
            switch p.ExtPressInstalled,
                case {'Druck'},
                    %ExtPress = 0.01*ConvertDruckPressure( &DruckCal, 0.001*LextPress, T );
                    p.pressdb = 0.01.*ConvertDruckPressure( p.extpressfreq, p.temp, p.presscals);
                case {'ParosFreq'}
                    p.pressdb = ParoNorm(p.PressFreqOffset,p.extpressfreq,p.temp,p.presscals);
            end
            p.stdpressdb = gstd(p.pressdb');
        else % if no cal constants, nothing to do
            p.pressdb = [];
            p.stdpressdb = [];
        end
    case 'Paros', % serial paros (smart paros) case
        % in some of these almost the whole burst is NG, and the "good"
        % ones aren't either, though they are't set to NaN
        % if < 5% good, force all to be NaN
        nx=find(isnan(p.extpress));
        if length(nx) > length(p.extpress)*.05
            p.pressdb = ones(size(p.extpress))*NaN;
            p.stdpressdb = NaN;
        else
            p.pressdb = p.extpress./1000; % convert from milli db to db
            p.stdpressdb = gstd(p.pressdb');
        end
end

return
end

function PressOut = ParoNorm(PressFreqOffset,PressFreq,Temp,cals)
	F0 = cals.F0; U0 = cals.U0; Y = cals.Y; C = cals.C; D = cals.D; T = cals.T;
	if Y(1),
        Temp = (-Y(1)-sqrt(Y(1).^2+4.*Temp.*Y(2)))./(2.*Y(2));
	end
	c = C(1) + C(2).*Temp + C(3).*(Temp.^2);
	d = D(1) + D(2).*Temp;
	t0 = T(1) + T(2).*Temp + T(3).*(Temp.^2) + T(4).*(Temp.^3) + T(5).*(Temp.^4);
	% the Sontek way
	tau = 1e6./PressFreq;
	delta = (t0./tau);  % also try t0.*PressOut./1e6;
	delta = (1-delta.^2);
	PressPsi = c.*delta.*(1-d.*delta);
	% or, from pnorm.m
	% K = 1.0-((t0.*PressFreq./1000000).^2);
	% PressPsi = c.*K.*(1-d.*K);
	
	PressOut = 68.947573.*PressPsi./100;
return
end

function PressOut = ConvertDruckPressure( PressFreq, Temp, cals )
    diode = cals.D0 + cals.DTslope*(Temp-cals.T0);
    Xp = PressFreq-cals.X;
    Yp = diode-cals.Y;
    K = reshape(cals.K, 6, 4); 

    XpN = ones(6,length(PressFreq)).*NaN;
    XpN(1,:) = ones(1,length(PressFreq));
    for i=2:6, 
        XpN(i,:) = XpN(i-1,:).*Xp'; 
    end

    YpN = ones(4,length(PressFreq)).*NaN;
    YpN(1,:) = ones(1,length(PressFreq));
    for i=2:4, 
        YpN(i,:) = YpN(i-1,:).*Yp'; 
    end

    PressOut = 0;
    for i=1:6, 
        for j=1:4,
            PressOut = PressOut + K(i,j).*XpN(i,:).*YpN(j,:);
        end
    end
return
end

% ******************************************************************************************
% this code is not used but is included for reference.
%

% from ADVDATA.C
% double ConvertDruckPressure( DruckCalType *Dc, double F, double T )
% {
%   double Xp, Yp, diode, p;
%   double XpN[6], YpN[4];
%   int i,j;
% 
%   diode = Dc->D0 + Dc->DTslope*(T-Dc->T0);
%   Xp = F-Dc->X;
%   Yp = diode-Dc->Y;
% 
%   XpN[0] = 1;
%   for(i=1;i<6;i++) XpN[i] = XpN[i-1] * Xp;
% 
%   YpN[0] = 1;
%   for(i=1;i<4;i++) YpN[i] = YpN[i-1] * Yp;
% 
%   p = 0;
% 
%   for(i=0;i<6;i++) for(j=0;j<4;j++) p += Dc->K[i][j] * XpN[i] * YpN[j];
% 
%   return(p);
% }
% 

% /*---------------------------------------------------------------------------*/
% /*                                                                           */
% /*     Druck pressure sensor calibration parameters                          */
% /*                                                                           */
% /*                                                                           */
% typedef struct
% {
%   char   SerNum[10];
%   double F0;               /* Frequency of Druck sampling board */
%   double X;
%   double Y;
%   double T0;
%   double D0;
%   double DTslope;
%   double K[6][4];
% } DruckCalType;

% int LoadDruckCalFromFile( char *CalFile, DruckCalType *Dc )
% {
%   FILE *fi;
%   int i,j;
% 
%   if((fi = fopen(CalFile,"r")) == NULL) goto No_File;
% 
%   if(fscanf(fi,"%s", Dc->SerNum )    != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->F0)       != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->X )       != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->Y )       != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->T0 )      != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->D0 )      != 1) goto Bad_File;
%   if(fscanf(fi,"%lg", &Dc->DTslope ) != 1) goto Bad_File;
%   for(i=0;i<=5;i++) for(j=0;j<=3;j++)
%      if(fscanf(fi,"%lg", &Dc->K[i][j] ) != 1) goto Bad_File;
%   return(0);
% 
% No_File:
%   printf("\n\n***ERROR:   Cannot open Druck calibration file: %s",CalFile);
%   return(1);
% Bad_File:
%   printf("\n\n***ERROR:   Corrupted Druck calibration file: %s",CalFile);
%   return(1);
% }

% if(DruckCalFile[0])
%     {
%         if     (TempPressData[BurstType]) T = 0.01*Temp;
%         else if(StatData[BurstType])      T = 0.01*AdvStat.MeanTemp;
%         else                              T = 0.1*AdvDep.Temp;
%         ExtPress = 0.01*ConvertDruckPressure( &DruckCal, 0.001*LextPress, T );
%         }

% % convert ADV pressure from counts to db
% function [PressOut,StdPressOut] = ConvertADVExtPress(ExtPressInstalled,...
%     PressOffset,PressScale,PressScale_2,...
%     PressFreqOffset,MeanPress,StdPress,MeanTemp,cals)
% if ~ExtPressInstalled,
%     StdPressOut = PressScale.*StdPress;
%     PressOut = PressOffset + PressScale.*MeanPress + PressScale_2.*(MeanPress.^2);
% end
% switch ExtPressInstalled,
%     case {'ParosFreq', 'Druck'},
%         PressFreq = (PressFreqOffset.*1000000 + MeanPress).*0.001; 
%         if ~isempty(cals), % if there are cal constants
%             % note that MeanTemp was converted to degrees when read from the binary
%             switch ExtPressInstalled,
%                 case {'Druck'},
%                     % Druck not added yet.
%                     PressOut = PressFreq;
%                 case {'ParosFreq'}
%                     F0 = cals.F0; U0 = cals.U0; Y = cals.Y; C = cals.C; D = cals.D; T = cals.T;
%                     if Y(1),
%                         MeanTemp = (-Y(1)-sqrt(Y(1).^2+4.*MeanTemp.*Y(2)))./(2.*Y(2));
%                     end
%                     c = C(1) + C(2).*MeanTemp + C(3).*(MeanTemp.^2);
%                     d = D(1) + D(2).*MeanTemp;
%                     t0 = T(1) + T(2).*MeanTemp + T(3).*(MeanTemp.^2) + T(4).*(MeanTemp.^3) + T(5).*(MeanTemp.^4);
%                     % the Sontek way
%                     tau = 1e6./PressFreq;
%                     delta = (t0./tau);  % also try t0.*PressOut./1e6;
%                     delta = (1-delta.^2);
%                     PressPsi = c.*delta.*(1-d.*delta);
%                     % or, from pnorm.m
%                     % K = 1.0-((t0.*PressFreq./1000000).^2);
%                     % PressPsi = c.*K.*(1-d.*K);
%                     
%                     PressDb = 68.947573.*PressPsi;
%                     PressOut = PressDb./100;
%             end
%         else % if no cal constants, output the frequency
%             PressOut = PressFreq;
%         end
%         StdPressOut = StdPress.*0; % meaningless without the Msb's
%     otherwise % no external pressure or not Freqency Paros do nothing for now
% end
% return
% 
% % convert PCADP pressure from counts to db
% function [PressOut,StdPressOut] = ConvertPCADPExtPress(ExtPressInstalled,...
%     PressOffset,PressScale,PressScale_2,...
%     PCMode,PressFreqOffset,MsbPress,MeanPress,StdPress,MeanTemp,cals)
% if ~ExtPressInstalled,
%     StdPressOut = PressScale.*StdPress;
%     PressOut = PressOffset + PressScale.*MeanPress + PressScale_2.*(MeanPress.^2);
% end
% if strcmp(PCMode, 'Yes'), % must put the LSBs and LSB back together to get the right value
%     switch ExtPressInstalled,
%         case {'ParosFreq', 'Druck'},
%             PressFreq = (PressFreqOffset.*1000000 + MeanPress + MsbPress.*65536).*0.001; % shift left 16 bits
%             if ~isempty(cals), % if there are cal constants
%                 % note that MeanTemp was converted to degrees when read from the binary
%                 switch ExtPressInstalled,
%                     case {'Druck'},
%                         % Druck not added yet.
%                         PressOut = PressFreq;
%                     case {'ParosFreq'}
%                         F0 = cals.F0; U0 = cals.U0; Y = cals.Y; C = cals.C; D = cals.D; T = cals.T;
%                         if Y(1),
%                             MeanTemp = (-Y(1)-sqrt(Y(1).^2+4.*MeanTemp.*Y(2)))./(2.*Y(2));
%                         end
%                         c = C(1) + C(2).*MeanTemp + C(3).*(MeanTemp.^2);
%                         d = D(1) + D(2).*MeanTemp;
%                         t0 = T(1) + T(2).*MeanTemp + T(3).*(MeanTemp.^2) + T(4).*(MeanTemp.^3) + T(5).*(MeanTemp.^4);
%                         % the Sontek way
%                         tau = 1e6./PressFreq;
%                         delta = (t0./tau);  % also try t0.*PressOut./1e6;
%                         delta = (1-delta.^2);
%                         PressPsi = c.*delta.*(1-d.*delta);
%                         % or, from pnorm.m
%                         % K = 1.0-((t0.*PressFreq./1000000).^2);
%                         % PressPsi = c.*K.*(1-d.*K);
%                         
%                         PressDb = 68.947573.*PressPsi;
%                         PressOut = PressDb./100;
%                 end
%             else % if no cal constants, output the frequency
%                 PressOut = PressFreq;
%             end
%             StdPressOut = StdPress.*0; % meaningless without the Msb's
%         otherwise % no external pressure or not Freqency Paros do nothing for now
%     end
% else
%     switch ExtPressInstalled,
%         case {'ParosFreq', 'Druck'},
%             PressOut = MeanPress.*0.001;
%             StdPressOut = StdPress.*0.001;
%         otherwise % do nothing
%     end
% end
% return